{"version":3,"file":"preboot.umd.min.js","sources":["../../out-tsc/lib/common/get-node-key.ts","../../out-tsc/lib/api/event.replayer.ts","../../out-tsc/lib/api/event.recorder.ts","../../out-tsc/lib/api/inline.preboot.code.ts","../../out-tsc/lib/module.ts","../../out-tsc/lib/common/tokens.ts"],"sourcesContent":["import { NodeContext } from './preboot.interfaces';\n\n/**\n * Attempt to generate key from node position in the DOM\n */\nexport function getNodeKeyForPreboot(nodeContext: NodeContext): string {\n  const ancestors: Element[] = [];\n  const root = nodeContext.root;\n  const node = nodeContext.node;\n  let temp: Element | null = node;\n\n  // walk up the tree from the target node up to the root\n  while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n    ancestors.push(temp);\n    temp = temp.parentNode as Element;\n  }\n\n  // note: if temp doesn't exist here it means root node wasn't found\n  if (temp) {\n    ancestors.push(temp);\n  }\n\n  // now go backwards starting from the root, appending the appName to unique\n  // identify the node later..\n  const name = node.nodeName || 'unknown';\n  let key = name + '_' + root.serverSelector;\n  const len = ancestors.length;\n\n  for (let i = len - 1; i >= 0; i--) {\n    temp = ancestors[i];\n\n    if (temp.childNodes && i > 0) {\n      for (let j = 0; j < temp.childNodes.length; j++) {\n        if (temp.childNodes[j] === ancestors[i - 1]) {\n          key += '_s' + (j + 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return key;\n}\n","import {\n  NodeContext,\n  PrebootAppData,\n  PrebootData,\n  PrebootEvent,\n  PrebootWindow,\n  ServerClientRoot} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nexport function _window(): PrebootWindow {\n  return {\n    prebootData: (window as any)['prebootData'],\n    prebootStarted: false,\n    getComputedStyle: window.getComputedStyle,\n    document: document\n  };\n}\n\nexport class EventReplayer {\n  clientNodeCache: { [key: string]: Element } = {};\n  replayStarted = false;\n  win: PrebootWindow;\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  setWindow(win: PrebootWindow) {\n    this.win = win;\n  }\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  getWindow() {\n    if (!this.win) {\n      this.win = _window();\n    }\n    return this.win;\n  }\n\n  /**\n   * Replay all events for all apps. this can only be run once.\n   * if called multiple times, will only do something once\n   */\n  replayAll() {\n    if (this.replayStarted) {\n      return;\n    } else {\n      this.replayStarted = true;\n    }\n\n    // loop through each of the preboot apps\n    const prebootData = this.getWindow().prebootData || {};\n    const apps = prebootData.apps || [];\n    apps.forEach(appData => this.replayForApp(appData));\n\n    // once all events have been replayed and buffers switched, then we cleanup preboot\n    this.cleanup(prebootData);\n  }\n\n  /**\n   * Replay all events for one app (most of the time there is just one app)\n   * @param appData\n   */\n  replayForApp(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    // try catch around events b/c even if error occurs, we still move forward\n    try {\n      const root = <ServerClientRoot>(appData.root || {});\n      const events = appData.events || [];\n\n      // some client side frameworks (like Angular 1 w UI Router) will replace\n      // elements, so we need to re-get client root just to be safe\n      const doc = this.getWindow().document;\n      const clientSelector = root.clientSelector;\n      if (clientSelector != null) {\n        root.clientNode = doc.querySelector(clientSelector) as HTMLElement;\n      }\n\n      // replay all the events from the server view onto the client view\n      events.forEach(event => this.replayEvent(appData, event));\n    } catch (ex) {\n      console.error(ex);\n    }\n\n    // if we are buffering, switch the buffers\n    this.switchBuffer(appData);\n  }\n\n  /**\n   * Replay one particular event\n   * @param appData\n   * @param prebootEvent\n   */\n  replayEvent(appData: PrebootAppData, prebootEvent: PrebootEvent) {\n    appData = <PrebootAppData>(appData || {});\n    prebootEvent = <PrebootEvent>(prebootEvent || {});\n\n    const event = prebootEvent.event as Event;\n    const serverNode = prebootEvent.node || {};\n    const nodeKey = prebootEvent.nodeKey;\n    const clientNode = this.findClientNode({\n      root: appData.root,\n      node: serverNode,\n      nodeKey: nodeKey\n    });\n\n    // if client node can't be found, log a warning\n    if (!clientNode) {\n      console.warn(`Trying to dispatch event ${event.type} to node ${nodeKey} but could not find client node. Server node is: `);\n      console.log(serverNode);\n      return;\n    }\n\n    // now dispatch events and whatnot to the client node\n    (clientNode as HTMLInputElement).checked = serverNode.checked;\n    (clientNode as HTMLOptionElement).selected = serverNode.selected;\n    (clientNode as HTMLOptionElement).value = serverNode.value;\n    clientNode.dispatchEvent(event);\n  }\n\n  /**\n   * Switch the buffer for one particular app (i.e. display the client\n   * view and destroy the server view)\n   * @param appData\n   */\n  switchBuffer(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    const root = <ServerClientRoot>(appData.root || {});\n    const serverView = root.serverNode;\n    const clientView = root.clientNode;\n\n    // if no client view or the server view is the body or client\n    // and server view are the same, then don't do anything and return\n    if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {\n      return;\n    }\n\n    // do a try-catch just in case something messed up\n    try {\n      // get the server view display mode\n      const gcs = this.getWindow().getComputedStyle;\n      const display = gcs(serverView).getPropertyValue('display') || 'block';\n\n      // first remove the server view\n      serverView.remove ? serverView.remove() : (serverView.style.display = 'none');\n\n      // now add the client view\n      clientView.style.display = display;\n    } catch (ex) {\n      console.error(ex);\n    }\n  }\n\n  /**\n   * Finally, set focus, remove all the event listeners and remove\n   * any freeze screen that may be there\n   * @param prebootData\n   */\n  cleanup(prebootData: PrebootData) {\n    prebootData = prebootData || {};\n\n    const listeners = prebootData.listeners || [];\n\n    // set focus on the active node AFTER a small delay to ensure buffer\n    // switched\n    const activeNode = prebootData.activeNode;\n    if (activeNode != null) {\n      setTimeout(() => this.setFocus(activeNode), 1);\n    }\n\n    // remove all event listeners\n    for (const listener of listeners) {\n      listener.node.removeEventListener(listener.eventName, listener.handler);\n    }\n\n    // remove the freeze overlay if it exists\n    const doc = this.getWindow().document;\n    const prebootOverlay = doc.body.querySelector('#prebootOverlay') as HTMLElement;\n    if (prebootOverlay) {\n      prebootOverlay.remove();\n    }\n\n    // clear out the data stored for each app\n    prebootData.apps = [];\n    this.clientNodeCache = {};\n\n    // sent event to documernt that signals preboot complete\n    const completeEvent = new Event('PrebootComplete');\n    doc.dispatchEvent(completeEvent);\n  }\n\n  setFocus(activeNode: NodeContext) {\n    // only do something if there is an active node\n    if (!activeNode || !activeNode.node || !activeNode.nodeKey) {\n      return;\n    }\n\n    // find the client node in the new client view\n    const clientNode = this.findClientNode(activeNode);\n    if (clientNode) {\n      // set focus on the client node\n      clientNode.focus();\n\n      // set selection if a modern browser (i.e. IE9+, etc.)\n      const selection = activeNode.selection;\n      if ((clientNode as HTMLInputElement).setSelectionRange && selection) {\n        try {\n          (clientNode as HTMLInputElement).setSelectionRange(selection.start, selection.end, selection.direction);\n        } catch (ex) {}\n      }\n    }\n  }\n\n  /**\n   * Given a node from the server rendered view, find the equivalent\n   * node in the client rendered view. We do this by the following approach:\n   *      1. take the name of the server node tag (ex. div or h1 or input)\n   *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n   *      3. use that value as a selector to get all the matching client nodes\n   *      4. loop through all client nodes found and for each generate a key value\n   *      5. compare the client key to the server key; once there is a match,\n   *          we have our client node\n   *\n   * NOTE: this only works when the client view is almost exactly the same as\n   * the server view. we will need an improvement here in the future to account\n   * for situations where the client view is different in structure from the\n   * server view\n   */\n  findClientNode(serverNodeContext: NodeContext): HTMLElement | null {\n    serverNodeContext = <NodeContext>(serverNodeContext || {});\n\n    const serverNode = serverNodeContext.node;\n    const root = serverNodeContext.root;\n\n    // if no server or client root, don't do anything\n    if (!root || !root.serverNode || !root.clientNode) {\n      return null;\n    }\n\n    // we use the string of the node to compare to the client node & as key in\n    // cache\n    const serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);\n\n    // if client node already in cache, return it\n    if (this.clientNodeCache[serverNodeKey]) {\n      return this.clientNodeCache[serverNodeKey] as HTMLElement;\n    }\n\n    // get the selector for client nodes\n    const className = (serverNode.className || '').replace('ng-binding', '').trim();\n    let selector = serverNode.tagName;\n\n    if (serverNode.id) {\n      selector += '#' + serverNode.id;\n    } else if (className) {\n      selector += '.' + className.replace(/ /g, '.');\n    }\n\n    // select all possible client nodes and look through them to try and find a\n    // match\n    const rootClientNode = root.clientNode;\n    let clientNodes = rootClientNode.querySelectorAll(selector);\n\n    // if nothing found, then just try the tag name as a final option\n    if (!clientNodes.length) {\n      console.log('nothing found for ' + selector + ' so using ' + serverNode.tagName);\n      clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);\n    }\n\n    for (const clientNode of Array.from(clientNodes)) {\n      // get the key for the client node\n      const clientNodeKey = getNodeKeyForPreboot({\n        root: root,\n        node: clientNode\n      });\n\n      // if the client node key is exact match for the server node key, then we\n      // found the client node\n      if (clientNodeKey === serverNodeKey) {\n        this.clientNodeCache[serverNodeKey] = clientNode;\n        return clientNode as HTMLElement;\n      }\n    }\n\n    // if we get here and there is one clientNode, use it as a fallback\n    if (clientNodes.length === 1) {\n      this.clientNodeCache[serverNodeKey] = clientNodes[0];\n      return clientNodes[0] as HTMLElement;\n    }\n\n    // if we get here it means we couldn't find the client node so give the user\n    // a warning\n    console.warn(\n      'No matching client node found for ' + serverNodeKey + '. You can fix this by assigning this element a unique id attribute.'\n    );\n    return null;\n  }\n}\n","import {\n  EventSelector,\n  PrebootOptions,\n  PrebootAppData,\n  PrebootData,\n  DomEvent,\n  PrebootWindow,\n  ServerClientRoot,\n  PrebootSelection\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\n/**\n * Called right away to initialize preboot\n *\n * @param opts All the preboot options\n * @param win\n */\nexport function init(opts: PrebootOptions, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // add the preboot options to the preboot data and then add the data to\n  // the window so it can be used later by the client\n  const data = (theWindow.prebootData = <PrebootData>{\n    opts: opts,\n    listening: true,\n    apps: [],\n    listeners: []\n  });\n\n  // start up preboot listening as soon as the DOM is ready\n  waitUntilReady(data);\n}\n\n/**\n * We want to attach event handlers as soon as possible. Unfortunately this\n * means before DOMContentLoaded fires, so we need to look for document.body to\n * exist instead.\n * @param data\n * @param win\n */\nexport function waitUntilReady(data: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n  const doc = <Document>(theWindow.document || {});\n\n  if (doc.body) {\n    start(data);\n  } else {\n    setTimeout(function() {\n      waitUntilReady(data);\n    }, 10);\n  }\n}\n\n/**\n * Start up preboot by going through each app and assigning the appropriate\n * handlers. Normally this wouldn't be called directly, but we have set it up so\n * that it can for older versions of Universal.\n *\n * @param prebootData Global preboot data object that contains options and will\n * have events\n * @param win Optional param to pass in mock window for testing purposes\n */\nexport function start(prebootData: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // only start once\n  if (theWindow.prebootStarted) {\n    return;\n  } else {\n    theWindow.prebootStarted = true;\n  }\n\n  const document = <Document>(theWindow.document || {});\n  const opts = prebootData.opts || ({} as PrebootOptions);\n  const eventSelectors = opts.eventSelectors || [];\n\n  // create an overlay that can be used later if a freeze event occurs\n  prebootData.overlay = createOverlay(document);\n\n  // get an array of all the root info\n  const appRoots = prebootData.opts ? getAppRoots(document, prebootData.opts) : [];\n\n  // for each app root\n  appRoots.forEach(function(root) {\n    // we track all events for each app in the prebootData object which is on\n    // the global scope\n    const appData = <PrebootAppData>{ root: root, events: [] };\n    if (prebootData.apps) {\n      prebootData.apps.push(appData);\n    }\n\n    // loop through all the eventSelectors and create event handlers\n    eventSelectors.forEach(eventSelector => handleEvents(prebootData, appData, eventSelector));\n  });\n}\n\n/**\n * Create an overlay div and add it to the DOM so it can be used\n * if a freeze event occurs\n *\n * @param document The global document object (passed in for testing purposes)\n * @returns Element The overlay node is returned\n */\nexport function createOverlay(document: Document): Element | undefined {\n  let overlay = undefined;\n  if (document.createElement) {\n    overlay = document.createElement('div');\n    overlay.setAttribute('id', 'prebootOverlay');\n    overlay.setAttribute(\n      'style',\n      'display:none;position:absolute;left:0;' + 'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3'\n    );\n    document.body.appendChild(overlay);\n  }\n\n  return overlay;\n}\n\n/**\n * Get references to all app root nodes based on input options. Users can\n * initialize preboot either by specifying appRoot which is just one or more\n * selectors for apps. This section option is useful for people that are doing their own\n * buffering (i.e. they have their own client and server view)\n *\n * @param document The global document object passed in for testing purposes\n * @param opts Options passed in by the user to init()\n * @returns ServerClientRoot[] An array of root info for each app\n */\nexport function getAppRoots(doc: Document, opts: PrebootOptions): ServerClientRoot[] {\n  let roots: ServerClientRoot[] = [];\n\n  // loop through any appRoot selectors to add them to the list of roots\n  if (opts.appRoot && opts.appRoot.length) {\n    const baseList: string[] = [];\n    const appRootSelectors = baseList.concat(opts.appRoot);\n    appRootSelectors.forEach((selector: any) => roots.push({ serverSelector: selector }));\n  }\n\n  return roots.map(root => {\n    root.serverNode = doc.querySelector(root.serverSelector) as HTMLElement;\n    root.clientSelector = root.clientSelector || root.serverSelector;\n\n    if (root.clientSelector !== root.serverSelector) {\n      // if diff selectors, then just get the client node\n      root.clientNode = doc.querySelector(root.clientSelector) as HTMLElement;\n    } else {\n      // if we are doing buffering, we need to create the buffer for the client\n      // else the client root is the same as the server\n      root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;\n    }\n\n    // if no server node found, log error\n    if (!root.serverNode) {\n      console.log(`No server node found for selector: ${root.serverSelector}`);\n    }\n\n    return root;\n  });\n}\n\n/**\n * Under given server root, for given selector, record events\n *\n * @param prebootData\n * @param appData\n * @param eventSelector\n */\nexport function handleEvents(prebootData: PrebootData, appData: PrebootAppData, eventSelector: EventSelector) {\n  const serverRoot = appData.root.serverNode;\n\n  // don't do anything if no server root\n  if (!serverRoot) {\n    return;\n  }\n\n  // get all nodes under the server root that match the given selector\n  const nodes: NodeListOf<Element> = serverRoot.querySelectorAll(eventSelector.selector);\n\n  // don't do anything if no nodes found\n  if (!nodes) {\n    return;\n  }\n\n  // we want to add an event listener for each node and each event\n  for (const node of Array.from(nodes)) {\n    eventSelector.events.forEach((eventName: string) => {\n      // get the appropriate handler and add it as an event listener\n      const handler = createListenHandler(prebootData, eventSelector, appData, node);\n      node.addEventListener(eventName, handler);\n\n      // need to keep track of listeners so we can do node.removeEventListener()\n      // when preboot done\n      if (prebootData.listeners) {\n        prebootData.listeners.push({ node: node as HTMLElement, eventName: eventName, handler: handler });\n      }\n    });\n  }\n}\n\n/**\n * Create handler for events that we will record\n */\nexport function createListenHandler(\n  prebootData: PrebootData,\n  eventSelector: EventSelector,\n  appData: PrebootAppData,\n  node: Element\n): EventListener {\n  const CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];\n  const CARET_NODES = ['INPUT', 'TEXTAREA'];\n\n  return function(event: DomEvent) {\n    const root = appData.root;\n    const eventName = event.type;\n\n    // if no node or no event name or not listening, just return\n    if (!node || !eventName) {\n      return;\n    }\n\n    // if key codes set for eventSelector, then don't do anything if event\n    // doesn't include key\n    const keyCodes = eventSelector.keyCodes;\n    if (keyCodes && keyCodes.length) {\n      const matchingKeyCodes = keyCodes.filter(keyCode => event.which === keyCode);\n\n      // if there are not matches (i.e. key entered NOT one of the key codes)\n      // then don't do anything\n      if (!matchingKeyCodes.length) {\n        return;\n      }\n    }\n\n    // if for a given set of events we are preventing default, do that\n    if (eventSelector.preventDefault) {\n      event.preventDefault();\n    }\n\n    // if an action handler passed in, use that\n    if (eventSelector.action) {\n      eventSelector.action(node, event);\n    }\n\n    // get the node key for a given node\n    const nodeKey = getNodeKeyForPreboot({ root: root, node: node });\n\n    // if event on input or text area, record active node\n    if (CARET_EVENTS.indexOf(eventName) >= 0 && CARET_NODES.indexOf(node.tagName) >= 0) {\n      prebootData.activeNode = {\n        root: root,\n        node: node,\n        nodeKey: nodeKey,\n        selection: getSelection(node as HTMLInputElement)\n      };\n    } else if (eventName !== 'change' && eventName !== 'focusout') {\n      prebootData.activeNode = undefined;\n    }\n\n    // if we are freezing the UI\n    if (eventSelector.freeze) {\n      const overlay = prebootData.overlay as HTMLElement;\n\n      // show the overlay\n      overlay.style.display = 'block';\n\n      // hide the overlay after 10 seconds just in case preboot.complete() never\n      // called\n      setTimeout(() => {\n        overlay.style.display = 'none';\n      }, 10000);\n    }\n\n    // we will record events for later replay unless explicitly marked as\n    // doNotReplay\n    if (!eventSelector.noReplay) {\n      appData.events.push({ node: node, nodeKey: nodeKey, event: event, name: eventName });\n    }\n  };\n}\n\n/**\n * Get the selection data that is later used to set the cursor after client view\n * is active\n */\nexport function getSelection(node: HTMLInputElement): PrebootSelection {\n  node = node || {} as HTMLInputElement;\n\n  const nodeValue = node.value || '';\n  const selection = {\n    start: nodeValue.length,\n    end: nodeValue.length,\n    direction: 'forward'\n  };\n\n  // if browser support selectionStart on node (Chrome, FireFox, IE9+)\n  try {\n    if (node.selectionStart || node.selectionStart === 0) {\n      selection.start = node.selectionStart;\n      selection.end = node.selectionEnd;\n      selection.direction = node.selectionDirection;\n    }\n  } catch (ex) {}\n\n  return selection;\n}\n\n/**\n * Create buffer for a given node\n *\n * @param root All the data related to a particular app\n * @returns Returns the root client node.\n */\nexport function createBuffer(root: ServerClientRoot): HTMLElement {\n  const serverNode = root.serverNode;\n\n  // if no rootServerNode OR the selector is on the entire html doc or the body\n  // OR no parentNode, don't buffer\n  if (!serverNode || !serverNode.parentNode || root.serverSelector === 'html' || root.serverSelector === 'body') {\n    return serverNode as HTMLElement;\n  }\n\n  // create shallow clone of server root\n  const rootClientNode = serverNode.cloneNode(false) as HTMLElement;\n\n  // we want the client to write to a hidden div until the time for switching\n  // the buffers\n  rootClientNode.style.display = 'none';\n\n  // insert the client node before the server and return it\n  serverNode.parentNode.insertBefore(rootClientNode, serverNode);\n\n  // return the rootClientNode\n  return rootClientNode;\n}\n","import { PrebootOptions } from '../common/preboot.interfaces';\nimport { getNodeKeyForPreboot } from '../common/get-node-key';\n\nimport {\n  init,\n  waitUntilReady,\n  start,\n  createOverlay,\n  getAppRoots,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n} from './event.recorder';\n\nconst eventRecorder = {\n  waitUntilReady,\n  start,\n  createOverlay,\n  getAppRoots,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n};\n\ndeclare var require: any;\n\n// exporting default options in case developer wants to use these + custom on\n// top\nexport const defaultOptions = <PrebootOptions>{\n  buffer: true,\n  minify: true,\n\n  // these are the default events are are listening for an transfering from\n  // server view to client view\n  eventSelectors: [\n    // for recording changes in form elements\n    {\n      selector: 'input,textarea',\n      events: ['keypress', 'keyup', 'keydown', 'input', 'change']\n    },\n    { selector: 'select,option', events: ['change'] },\n\n    // when user hits return button in an input box\n    {\n      selector: 'input',\n      events: ['keyup'],\n      preventDefault: true,\n      keyCodes: [13],\n      freeze: true\n    },\n\n    // when user submit form (press enter, click on button/input[type=\"submit\"])\n    {\n      selector: 'form',\n      events: ['submit'],\n      preventDefault: true,\n      freeze: true\n    },\n\n    // for tracking focus (no need to replay)\n    {\n      selector: 'input,textarea',\n      events: ['focusin', 'focusout', 'mousedown', 'mouseup'],\n      noReplay: true\n    },\n\n    // user clicks on a button\n    {\n      selector: 'button',\n      events: ['click'],\n      preventDefault: true,\n      freeze: true\n    }\n  ]\n};\n\n/**\n * Get the event recorder code based on all functions in event.recorder.ts\n * and the getNodeKeyForPreboot function.\n */\nexport function getEventRecorderCode(): string {\n  const eventRecorderFunctions: string[] = [];\n\n  for (const funcName in eventRecorder) {\n    if (eventRecorder.hasOwnProperty(funcName)) {\n      const fn = (<any>eventRecorder)[funcName].toString();\n      const fnCleaned = fn.replace('common_1.', '');\n      eventRecorderFunctions.push(fnCleaned);\n    }\n  }\n\n  // this is common function used to get the node key\n  eventRecorderFunctions.push(getNodeKeyForPreboot.toString());\n\n  // add new line characters for readability\n  return '\\n\\n' + eventRecorderFunctions.join('\\n\\n') + '\\n\\n';\n}\n\n\n/**\n * Used by the server side version of preboot. The main purpose\n * is to get the inline code that can be inserted into the server view.\n *\n * @param customOptions PrebootRecordOptions that override the defaults\n * @returns Generated inline preboot code is returned\n */\nexport function getInlinePrebootCode(customOptions?: PrebootOptions): string {\n  const opts = <PrebootOptions>assign({}, defaultOptions, customOptions);\n\n  // safety check to make sure options passed in are valid\n  validateOptions(opts);\n\n  const optsStr = stringifyWithFunctions(opts);\n  const scriptCode = getEventRecorderCode();\n\n  // TODO re-add minification option?\n\n  // wrap inline preboot code with a self executing function in order to create scope\n  const initStr = init.toString();\n  return `(function() {\n      ${scriptCode}\n      (${initStr.replace('common_1.', '')}\n      )(${optsStr})\n    })()`;\n}\n\n/**\n * Throw an error if issues with any options\n * @param opts\n */\nexport function validateOptions(opts: PrebootOptions) {\n  if (!opts.appRoot || !opts.appRoot.length) {\n    throw new Error(\n      'The appRoot is missing from preboot options. ' +\n        'This is needed to find the root of your application. ' +\n        'Set this value in the preboot options to be a selector for the root element of your app.'\n    );\n  }\n}\n\n/**\n * Object.assign() is not fully supporting in TypeScript, so\n * this is just a simple implementation of it\n *\n * @param target The target object\n * @param optionSets Any number of addition objects that are added on top of the\n * target\n * @returns A new object that contains all the merged values\n */\nexport function assign(target: Object, ...optionSets: any[]): Object {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  const output = Object(target);\n  for (let index = 0; index < optionSets.length; index++) {\n    const source = optionSets[index];\n    if (source !== undefined && source !== null) {\n      for (const nextKey in source) {\n        if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n/**\n * Stringify an object and include functions. This is needed since we are\n * letting users pass in options that include custom functions for things like\n * the freeze handler or action when an event occurs\n *\n * @param obj This is the object you want to stringify that includes some\n * functions\n * @returns The stringified version of an object\n */\nexport function stringifyWithFunctions(obj: Object): string {\n  const FUNC_START = 'START_FUNCTION_HERE';\n  const FUNC_STOP = 'STOP_FUNCTION_HERE';\n\n  // first stringify except mark off functions with markers\n  let str = JSON.stringify(obj, function(_key, value) {\n    // if the value is a function, we want to wrap it with markers\n    if (!!(value && value.constructor && value.call && value.apply)) {\n      return FUNC_START + value.toString() + FUNC_STOP;\n    } else {\n      return value;\n    }\n  });\n\n  // now we use the markers to replace function strings with actual functions\n  let startFuncIdx = str.indexOf(FUNC_START);\n  let stopFuncIdx: number;\n  let fn: string;\n  while (startFuncIdx >= 0) {\n    stopFuncIdx = str.indexOf(FUNC_STOP);\n\n    // pull string out\n    fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);\n    fn = fn.replace(/\\\\n/g, '\\n');\n\n    str = str.substring(0, startFuncIdx - 1) + fn + str.substring(stopFuncIdx + FUNC_STOP.length + 1);\n    startFuncIdx = str.indexOf(FUNC_START);\n  }\n\n  return str;\n}\n","import {\n  Inject,\n  ModuleWithProviders,\n  NgModule,\n  Optional,\n  PLATFORM_ID,\n  RendererFactory2,\n  RendererType2,\n  ViewEncapsulation,\n  InjectionToken,\n  APP_BOOTSTRAP_LISTENER,\n} from '@angular/core';\nimport {EventReplayer} from './api/event.replayer';\nimport {DOCUMENT, isPlatformBrowser, isPlatformServer} from '@angular/common';\nimport {getInlinePrebootCode} from './api/inline.preboot.code';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {PREBOOT_NONCE} from './common/tokens';\n\nexport const PREBOOT_OPTIONS = new InjectionToken<PrebootOptions>('PrebootOptions');\n\nexport function addScript(doc: Document, rendererFactory: RendererFactory2, recordOpts: PrebootOptions, nonce: string, platformId: Object) {\n  // necessary because of angular/angular/issues/14485\n  const res = () => {\n    if (isPlatformServer(platformId)) {\n      const inlineCode = getInlinePrebootCode(recordOpts);\n      const renderType: RendererType2 = { id: '-1', encapsulation: ViewEncapsulation.None, styles: [], data: {} };\n      const renderer = rendererFactory.createRenderer(doc, renderType);\n      const script = renderer.createElement('script');\n      if (nonce) {\n        renderer.setProperty(script, 'nonce', nonce);\n      }\n      renderer.setValue(script, inlineCode);\n      renderer.insertBefore(doc.head, script, doc.head.firstChild);\n    }\n  };\n\n  return res;\n\n}\n\nexport function replay(eventReplayer: EventReplayer, replayOpts: PrebootOptions, platformId: Object) {\n  // necessary because of angular/angular/issues/14485\n  const res = () => {\n    if (isPlatformBrowser(platformId) && !replayOpts.noReplay) {\n      eventReplayer.replayAll();\n    }\n  };\n  return res;\n}\n\n@NgModule()\nexport class PrebootModule {\n  static withConfig(opts: PrebootOptions): ModuleWithProviders {\n    return {\n      ngModule: PrebootModule,\n      providers: [\n        EventReplayer,\n        { provide: PREBOOT_OPTIONS, useValue: opts },\n        {\n          provide: APP_BOOTSTRAP_LISTENER,\n          useFactory: addScript,\n          deps: [\n            DOCUMENT,\n            RendererFactory2,\n            PREBOOT_OPTIONS,\n            [new Optional(), new Inject(PREBOOT_NONCE)],\n            PLATFORM_ID\n          ],\n          multi: true\n        },\n        {\n          provide: APP_BOOTSTRAP_LISTENER,\n          useFactory: replay,\n          deps: [EventReplayer, PREBOOT_OPTIONS, PLATFORM_ID],\n          multi: true\n        }\n      ]\n    };\n  }\n}\n","import {InjectionToken} from '@angular/core';\n\nexport const PREBOOT_NONCE = new InjectionToken<string>('PrebootNonce');\n"],"names":["nodeContext","ancestors","root","node","temp","serverNode","clientNode","push","key","nodeName","serverSelector","i","length","childNodes","j","prebootData","prebootStarted","getComputedStyle","window","document","opts","win","waitUntilReady","listening","apps","listeners","data","body","start","setTimeout","theWindow","eventSelectors","overlay","createOverlay","getAppRoots","forEach","appData","events","eventSelector","handleEvents","undefined","createElement","setAttribute","appendChild","doc","roots","appRoot","concat","selector","map","querySelector","clientSelector","buffer","createBuffer","console","log","serverRoot","nodes","querySelectorAll","eventName","handler","createListenHandler","addEventListener","_a","Array","from","_i","CARET_EVENTS","CARET_NODES","event","type","keyCodes","filter","keyCode","which","preventDefault","action","nodeKey","getNodeKeyForPreboot","indexOf","tagName","activeNode","selection","getSelection","freeze","overlay_1","style","display","noReplay","name","nodeValue","value","end","direction","selectionStart","selectionEnd","selectionDirection","ex","parentNode","rootClientNode","cloneNode","insertBefore","eventRecorderFunctions","funcName","eventRecorder","hasOwnProperty","fnCleaned","toString","replace","join","customOptions","assign","defaultOptions","validateOptions","optsStr","stringifyWithFunctions","getEventRecorderCode","init","Error","target","optionSets","TypeError","output","Object","index","source","nextKey","obj","stopFuncIdx","fn","FUNC_START","FUNC_STOP","str","JSON","stringify","_key","constructor","call","apply","startFuncIdx","substring","rendererFactory","recordOpts","nonce","platformId","isPlatformServer","inlineCode","getInlinePrebootCode","renderType","id","encapsulation","ViewEncapsulation","None","styles","renderer","createRenderer","script","setProperty","setValue","head","firstChild","eventReplayer","replayOpts","isPlatformBrowser","replayAll","PREBOOT_NONCE","InjectionToken","EventReplayer","this","_window","replayStarted","getWindow","_this","replayForApp","cleanup","replayEvent","error","switchBuffer","prebootEvent","findClientNode","warn","checked","selected","dispatchEvent","serverView","clientView","gcs","getPropertyValue","remove","setFocus","listeners_1","listener","removeEventListener","prebootOverlay","clientNodeCache","completeEvent","Event","focus","setSelectionRange","serverNodeContext","serverNodeKey","className","trim","clientNodes","minify","PREBOOT_OPTIONS","PrebootModule","ngModule","providers","provide","useValue","APP_BOOTSTRAP_LISTENER","useFactory","addScript","deps","DOCUMENT","RendererFactory2","Optional","Inject","PLATFORM_ID","multi","replay","NgModule"],"mappings":"qTAKA,WAAqCA,GAOnC,IANA,IAAMC,KACAC,EAAOF,EAAYE,KACnBC,EAAOH,EAAYG,KACrBC,EAAuBD,EAGpBC,GAAQA,IAASF,EAAKG,YAAcD,IAASF,EAAKI,YACvDL,EAAUM,KAAKH,GACfA,EAAOA,EAA0B,WAI/BA,GACFH,EAAUM,KAAKH,GASjB,IAAK,IAHDI,GADSL,EAAKM,UAAY,WACb,IAAMP,EAAKQ,eAGnBC,EAFGV,EAAUW,OAEH,EAAGD,GAAK,EAAGA,IAG5B,IAFAP,EAAOH,EAAUU,IAERE,YAAcF,EAAI,EACzB,IAAK,IAAIG,EAAI,EAAGA,EAAIV,EAAKS,WAAWD,OAAQE,IAC1C,GAAIV,EAAKS,WAAWC,KAAOb,EAAUU,EAAI,GAAI,CAC3CH,GAAO,MAAQM,EAAI,GACnB,MAMR,OAAON,EChCT,aACE,OACEO,YAAa,OAA6B,YAC1CC,gBAAgB,EAChBC,iBAAkBC,OAAOD,iBACzBE,SAAUA,UCId,WAAqBC,EAAsBC,GAazCC,GAZkCD,GAAOH,QAIjBH,aACtBK,KAAMA,EACNG,WAAW,EACXC,QACAC,eAcJ,WAA+BC,EAAmBL,KACdA,GAAOH,QACRC,cAEzBQ,KACNC,EAAMF,GAENG,WAAW,WACTP,EAAeI,IACd,IAaP,WAAsBX,EAA0BM,GAC9C,IAAMS,EAA4BT,GAAOH,OAGzC,IAAIY,EAAUd,eAAd,CAGEc,EAAUd,gBAAiB,EAG7B,IAAMG,EAAsBW,EAAUX,aAEhCY,GADOhB,EAAYK,UACGW,mBAG5BhB,EAAYiB,QAAUC,EAAcd,IAGnBJ,EAAYK,KAAOc,EAAYf,EAAUJ,EAAYK,UAG7De,QAAQ,SAASjC,GAGxB,IAAMkC,GAA4BlC,KAAMA,EAAMmC,WAC1CtB,EAAYS,MACdT,EAAYS,KAAKjB,KAAK6B,GAIxBL,EAAeI,QAAQ,SAAAG,GAAiB,OAAAC,EAAaxB,EAAaqB,EAASE,QAW/E,WAA8BnB,GAC5B,IAAIa,OAAUQ,EAWd,OAVIrB,EAASsB,iBACXT,EAAUb,EAASsB,cAAc,QACzBC,aAAa,KAAM,kBAC3BV,EAAQU,aACN,QACA,iHAEFvB,EAASQ,KAAKgB,YAAYX,IAGrBA,EAaT,WAA4BY,EAAexB,GACzC,IAAIyB,KAGJ,GAAIzB,EAAK0B,SAAW1B,EAAK0B,QAAQlC,OAAQ,IAELmC,OAAO3B,EAAK0B,SAC7BX,QAAQ,SAACa,GAAkB,OAAAH,EAAMtC,MAAOG,eAAgBsC,MAG3E,OAAOH,EAAMI,IAAI,SAAA/C,GAkBf,OAjBAA,EAAKG,WAAauC,EAAIM,cAAchD,EAAKQ,gBACzCR,EAAKiD,eAAiBjD,EAAKiD,gBAAkBjD,EAAKQ,eAE9CR,EAAKiD,iBAAmBjD,EAAKQ,eAE/BR,EAAKI,WAAasC,EAAIM,cAAchD,EAAKiD,gBAIzCjD,EAAKI,WAAac,EAAKgC,OAASC,EAAanD,GAAQA,EAAKG,WAIvDH,EAAKG,YACRiD,QAAQC,IAAI,sCAAsCrD,EAAKQ,gBAGlDR,IAWX,WAA6Ba,EAA0BqB,EAAyBE,GAC9E,IAAMkB,EAAapB,EAAQlC,KAAKG,WAGhC,GAAKmD,EAAL,CAKA,IAAMC,EAA6BD,EAAWE,iBAAiBpB,EAAcU,UAG7E,GAAKS,EAKL,IAAmB,eAARtD,GACTmC,EAAcD,OAAOF,QAAQ,SAACwB,GAE5B,IAAMC,EAAUC,EAAoB9C,EAAauB,EAAeF,EAASjC,GACzEA,EAAK2D,iBAAiBH,EAAWC,GAI7B7C,EAAYU,WACdV,EAAYU,UAAUlB,MAAOJ,OAA2BwD,UAAWA,EAAWC,QAASA,WAT1EG,EAAAC,MAAMC,KAAKR,GAAXS,WAAAA,eAkBrB,WACEnD,EACAuB,EACAF,EACAjC,GAEA,IAAMgE,GAAgB,QAAS,UAAW,UAAW,UAAW,aAC1DC,GAAe,QAAS,YAE9B,OAAO,SAASC,GACd,IAAMnE,EAAOkC,EAAQlC,KACfyD,EAAYU,EAAMC,KAGxB,GAAKnE,GAASwD,EAAd,CAMA,IAAMY,EAAWjC,EAAciC,SAC/B,GAAIA,GAAYA,EAAS3D,OAAQ,CAK/B,IAJyB2D,EAASC,OAAO,SAAAC,GAAW,OAAAJ,EAAMK,QAAUD,IAI9C7D,OACpB,OAKA0B,EAAcqC,gBAChBN,EAAMM,iBAIJrC,EAAcsC,QAChBtC,EAAcsC,OAAOzE,EAAMkE,GAI7B,IAAMQ,EAAUC,GAAuB5E,KAAMA,EAAMC,KAAMA,IAezD,GAZIgE,EAAaY,QAAQpB,IAAc,GAAKS,EAAYW,QAAQ5E,EAAK6E,UAAY,EAC/EjE,EAAYkE,YACV/E,KAAMA,EACNC,KAAMA,EACN0E,QAASA,EACTK,UAAWC,MAEU,WAAdxB,GAAwC,aAAdA,IACnC5C,EAAYkE,gBAAazC,GAIvBF,EAAc8C,OAAQ,CACxB,IAAMC,EAAUtE,EAAkC,QAGlDsE,EAAQC,MAAMC,QAAU,QAIxB1D,WAAW,WACTwD,EAAQC,MAAMC,QAAU,QACvB,KAKAjD,EAAckD,UACjBpD,EAAQC,OAAO9B,MAAOJ,KAAMA,EAAM0E,QAASA,EAASR,MAAOA,EAAOoB,KAAM9B,MAS9E,WAA6BxD,GAG3B,IAAMuF,GAFNvF,EAAOA,OAEgBwF,OAAS,GAC1BT,GACJtD,MAAO8D,EAAU9E,OACjBgF,IAAKF,EAAU9E,OACfiF,UAAW,WAIb,KACM1F,EAAK2F,gBAA0C,IAAxB3F,EAAK2F,kBAC9BZ,EAAUtD,MAAQzB,EAAK2F,eACvBZ,EAAUU,IAAMzF,EAAK4F,aACrBb,EAAUW,UAAY1F,EAAK6F,oBAE7B,MAAOC,IAET,OAAOf,EAST,WAA6BhF,GAC3B,IAAMG,EAAaH,EAAKG,WAIxB,IAAKA,IAAeA,EAAW6F,YAAsC,SAAxBhG,EAAKQ,gBAAqD,SAAxBR,EAAKQ,eAClF,SAIF,IAAMyF,EAAiB9F,EAAW+F,WAAU,GAU5C,OANAD,EAAeb,MAAMC,QAAU,OAG/BlF,EAAW6F,WAAWG,aAAaF,EAAgB9F,GAG5C8F,EC3PT,aACE,IAAMG,KAEN,IAAK,IAAMC,KAAYC,EACrB,GAAIA,EAAcC,eAAeF,GAAW,CAC1C,IACMG,EADK,EAAqBH,GAAUI,WACrBC,QAAQ,YAAa,IAC1CN,EAAuB/F,KAAKmG,GAQhC,OAHAJ,EAAuB/F,KAAKuE,EAAqB6B,YAG1C,OAASL,EAAuBO,KAAK,QAAU,OAWxD,WAAqCC,GACnC,IAAM1F,EAAuB2F,KAAWC,EAAgBF,GAGxDG,EAAgB7F,GAEhB,IAAM8F,EAAUC,EAAuB/F,GAOvC,MAAO,wBANYgG,gBAKHC,EAAKV,WAGNC,QAAQ,YAAa,iBAC5BM,gBAQV,WAAgC9F,GAC9B,IAAKA,EAAK0B,UAAY1B,EAAK0B,QAAQlC,OACjC,MAAM,IAAI0G,MACR,8LAgBN,WAAuBC,OAAgB,aAAArD,mBAAAA,IAAAsD,oBACrC,QAAehF,IAAX+E,GAAmC,OAAXA,EAC1B,MAAM,IAAIE,UAAU,8CAItB,IAAK,IADCC,EAASC,OAAOJ,GACbK,EAAQ,EAAGA,EAAQJ,EAAW5G,OAAQgH,IAAS,CACtD,IAAMC,EAASL,EAAWI,GAC1B,QAAepF,IAAXqF,GAAmC,OAAXA,EAC1B,IAAK,IAAMC,KAAWD,EAChBA,EAAOpB,gBAAkBoB,EAAOpB,eAAeqB,KACjDJ,EAAOI,GAAWD,EAAOC,IAMjC,OAAOJ,EAYT,WAAuCK,GAkBrC,IAjBA,IAeIC,EACAC,EAhBEC,EAAa,sBACbC,EAAY,qBAGdC,EAAMC,KAAKC,UAAUP,EAAK,SAASQ,EAAM5C,GAE3C,OAAOA,GAASA,EAAM6C,aAAe7C,EAAM8C,MAAQ9C,EAAM+C,MAChDR,EAAavC,EAAMgB,WAAawB,EAEhCxC,IAKPgD,EAAeP,EAAIrD,QAAQmD,GAGxBS,GAAgB,GACrBX,EAAcI,EAAIrD,QAAQoD,GAI1BF,GADAA,EAAKG,EAAIQ,UAAUD,EAAeT,EAAWtH,OAAQoH,IAC7CpB,QAAQ,OAAQ,MAGxB+B,GADAP,EAAMA,EAAIQ,UAAU,EAAGD,EAAe,GAAKV,EAAKG,EAAIQ,UAAUZ,EAAcG,EAAUvH,OAAS,IAC5EmE,QAAQmD,GAG7B,OAAOE,EC7LT,WAA0BxF,EAAeiG,EAAmCC,EAA4BC,EAAeC,GAgBrH,OAdY,WACV,GAAIC,mBAAiBD,GAAa,CAChC,IAAME,EAAaC,EAAqBL,GAClCM,GAA8BC,GAAI,KAAMC,cAAeC,oBAAkBC,KAAMC,UAAY/H,SAC3FgI,EAAWb,EAAgBc,eAAe/G,EAAKwG,GAC/CQ,EAASF,EAASjH,cAAc,UAClCsG,GACFW,EAASG,YAAYD,EAAQ,QAASb,GAExCW,EAASI,SAASF,EAAQV,GAC1BQ,EAASrD,aAAazD,EAAImH,KAAMH,EAAQhH,EAAImH,KAAKC,cAQvD,WAAuBC,EAA8BC,EAA4BlB,GAO/E,OALY,WACNmB,oBAAkBnB,KAAgBkB,EAAW1E,UAC/CyE,EAAcG,aC5CpB,IAEaC,EAAgB,IAAIC,iBAAuB,gBJgBxDC,sEAEkB,SAOhBA,sBAAA,SAAUlJ,GACRmJ,KAAKnJ,IAAMA,GAObkJ,sBAAA,WAIE,OAHKC,KAAKnJ,MACRmJ,KAAKnJ,IAAMoJ,KAEND,KAAKnJ,KAOdkJ,sBAAA,WAAA,WACE,IAAIC,KAAKE,cAAT,CAGEF,KAAKE,eAAgB,EAIvB,IAAM3J,EAAcyJ,KAAKG,YAAY5J,iBACxBA,EAAYS,UACpBW,QAAQ,SAAAC,GAAW,OAAAwI,EAAKC,aAAazI,KAG1CoI,KAAKM,QAAQ/J,KAOfwJ,yBAAA,SAAanI,GAAb,WACEA,EAA2BA,MAG3B,IACE,IAAMlC,EAA0BkC,EAAQlC,SAClCmC,EAASD,EAAQC,WAIjBO,EAAM4H,KAAKG,YAAYxJ,SACvBgC,EAAiBjD,EAAKiD,eACN,MAAlBA,IACFjD,EAAKI,WAAasC,EAAIM,cAAcC,IAItCd,EAAOF,QAAQ,SAAAkC,GAAS,OAAAuG,EAAKG,YAAY3I,EAASiC,KAClD,MAAO4B,GACP3C,QAAQ0H,MAAM/E,GAIhBuE,KAAKS,aAAa7I,IAQpBmI,wBAAA,SAAYnI,EAAyB8I,GACnC9I,EAA2BA,MAG3B,IAAMiC,GAFN6G,EAA8BA,OAEW,MACnC7K,EAAa6K,EAAa/K,SAC1B0E,EAAUqG,EAAarG,QACvBvE,EAAakK,KAAKW,gBACtBjL,KAAMkC,EAAQlC,KACdC,KAAME,EACNwE,QAASA,IAIX,IAAKvE,EAGH,OAFAgD,QAAQ8H,KAAK,4BAA4B/G,EAAMC,iBAAgBO,4DAC/DvB,QAAQC,IAAIlD,GAKd,EAAiCgL,QAAUhL,EAAWgL,QACtD,EAAkCC,SAAWjL,EAAWiL,SACxD,EAAkC3F,MAAQtF,EAAWsF,MACrDrF,EAAWiL,cAAclH,IAQ3BkG,yBAAA,SAAanI,GAGX,IAAMlC,GAFNkC,EAA2BA,OAEalC,SAClCsL,EAAatL,EAAKG,WAClBoL,EAAavL,EAAKI,WAIxB,GAAKmL,GAAeD,GAAcA,IAAeC,GAAsC,SAAxBD,EAAW/K,SAK1E,IAEE,IACM8E,GAAUmG,EADJlB,KAAKG,YAAY1J,kBACTuK,GAAYG,iBAAiB,YAAc,QAG/DH,EAAWI,OAASJ,EAAWI,SAAYJ,EAAWlG,MAAMC,QAAU,OAGtEkG,EAAWnG,MAAMC,QAAUA,EAC3B,MAAOU,GACP3C,QAAQ0H,MAAM/E,KASlBsE,oBAAA,SAAQxJ,GAAR,WAGQU,GAFNV,EAAcA,OAEgBU,cAIxBwD,EAAalE,EAAYkE,WACb,MAAdA,GACFpD,WAAW,WAAM,OAAA+I,EAAKiB,SAAS5G,IAAa,GAI9C,IAAuB,QAAA6G,IAAA5H,WAAAA,KAAlB,IAAM6H,OACTA,EAAS5L,KAAK6L,oBAAoBD,EAASpI,UAAWoI,EAASnI,SAIjE,IAAMhB,EAAM4H,KAAKG,YAAYxJ,SACvB8K,EAAiBrJ,EAAIjB,KAAKuB,cAAc,mBAC1C+I,GACFA,EAAeL,SAIjB7K,EAAYS,QACZgJ,KAAK0B,mBAGL,IAAMC,EAAgB,IAAIC,MAAM,mBAChCxJ,EAAI2I,cAAcY,IAGpB5B,qBAAA,SAAStF,GAEP,GAAKA,GAAeA,EAAW9E,MAAS8E,EAAWJ,QAAnD,CAKA,IAAMvE,EAAakK,KAAKW,eAAelG,GACvC,GAAI3E,EAAY,CAEdA,EAAW+L,QAGX,IAAMnH,EAAYD,EAAWC,UAC7B,GAAI,EAAiCoH,mBAAqBpH,EACxD,IACE,EAAiCoH,kBAAkBpH,EAAUtD,MAAOsD,EAAUU,IAAKV,EAAUW,WAC7F,MAAOI,QAoBfsE,2BAAA,SAAegC,GAGb,IAAMlM,GAFNkM,EAAkCA,OAEGpM,KAC/BD,EAAOqM,EAAkBrM,KAG/B,IAAKA,IAASA,EAAKG,aAAeH,EAAKI,WACrC,OAAO,KAKT,IAAMkM,EAAgBD,EAAkB1H,SAAWC,EAAqByH,GAGxE,GAAI/B,KAAK0B,gBAAgBM,GACvB,OAAOhC,KAAK0B,gBAAgBM,GAI9B,IAAMC,GAAapM,EAAWoM,WAAa,IAAI7F,QAAQ,aAAc,IAAI8F,OACrE1J,EAAW3C,EAAW2E,QAEtB3E,EAAWgJ,GACbrG,GAAY,IAAM3C,EAAWgJ,GACpBoD,IACTzJ,GAAY,IAAMyJ,EAAU7F,QAAQ,KAAM,MAK5C,IAAMT,EAAiBjG,EAAKI,WACxBqM,EAAcxG,EAAezC,iBAAiBV,GAG7C2J,EAAY/L,SACf0C,QAAQC,IAAI,qBAAuBP,EAAW,aAAe3C,EAAW2E,SACxE2H,EAAcxG,EAAezC,iBAAiBrD,EAAW2E,UAG3D,IAAyB,QAAAjB,EAAAC,MAAMC,KAAK0I,GAAXzI,WAAAA,KAApB,IAAM5D,OAST,GAPsBwE,GACpB5E,KAAMA,EACNC,KAAMG,MAKckM,EAEpB,OADAhC,KAAK0B,gBAAgBM,GAAiBlM,IAM1C,OAA2B,IAAvBqM,EAAY/L,QACd4J,KAAK0B,gBAAgBM,GAAiBG,EAAY,GAC3CA,EAAY,KAKrBrJ,QAAQ8H,KACN,qCAAuCoB,EAAgB,uEAElD,YE7RLhG,GACJlF,iBACAM,QACAK,gBACAC,cACAK,eACAsB,sBACAsB,eACA9B,gBAOW2D,GACX5D,QAAQ,EACRwJ,QAAQ,EAIR7K,iBAGIiB,SAAU,iBACVX,QAAS,WAAY,QAAS,UAAW,QAAS,YAElDW,SAAU,gBAAiBX,QAAS,YAIpCW,SAAU,QACVX,QAAS,SACTsC,gBAAgB,EAChBJ,UAAW,IACXa,QAAQ,IAKRpC,SAAU,OACVX,QAAS,UACTsC,gBAAgB,EAChBS,QAAQ,IAKRpC,SAAU,iBACVX,QAAS,UAAW,WAAY,YAAa,WAC7CmD,UAAU,IAKVxC,SAAU,SACVX,QAAS,SACTsC,gBAAgB,EAChBS,QAAQ,KCvDDyH,EAAkB,IAAIvC,iBAA+B,oDAkCzDwC,aAAP,SAAkB1L,GAChB,OACE2L,SAAUD,EACVE,WACEzC,GACE0C,QAASJ,EAAiBK,SAAU9L,IAEpC6L,QAASE,yBACTC,WAAYC,EACZC,MACEC,WACAC,mBACAX,GACC,IAAIY,WAAY,IAAIC,SAAOrD,IAC5BsD,eAEFC,OAAO,IAGPX,QAASE,yBACTC,WAAYS,EACZP,MAAO/C,EAAesC,EAAiBc,eACvCC,OAAO,0BAxBhBE"}