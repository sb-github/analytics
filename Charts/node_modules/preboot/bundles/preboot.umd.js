(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common'], factory) :
	(factory((global.preboot = global.preboot || {}),global.ng.core,global.ng.common));
}(this, (function (exports,_angular_core,_angular_common) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Attempt to generate key from node position in the DOM
 * @param {?} nodeContext
 * @return {?}
 */
function getNodeKeyForPreboot(nodeContext) {
    var /** @type {?} */ ancestors = [];
    var /** @type {?} */ root = nodeContext.root;
    var /** @type {?} */ node = nodeContext.node;
    var /** @type {?} */ temp = node;
    // walk up the tree from the target node up to the root
    while (temp && temp !== root.serverNode && temp !== root.clientNode) {
        ancestors.push(temp);
        temp = /** @type {?} */ (temp.parentNode);
    }
    // note: if temp doesn't exist here it means root node wasn't found
    if (temp) {
        ancestors.push(temp);
    }
    // now go backwards starting from the root, appending the appName to unique
    // identify the node later..
    var /** @type {?} */ name = node.nodeName || 'unknown';
    var /** @type {?} */ key = name + '_' + root.serverSelector;
    var /** @type {?} */ len = ancestors.length;
    for (var /** @type {?} */ i = len - 1; i >= 0; i--) {
        temp = ancestors[i];
        if (temp.childNodes && i > 0) {
            for (var /** @type {?} */ j = 0; j < temp.childNodes.length; j++) {
                if (temp.childNodes[j] === ancestors[i - 1]) {
                    key += '_s' + (j + 1);
                    break;
                }
            }
        }
    }
    return key;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PREBOOT_NONCE = new _angular_core.InjectionToken('PrebootNonce');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function _window() {
    return {
        prebootData: (/** @type {?} */ (window))['prebootData'],
        prebootStarted: false,
        getComputedStyle: window.getComputedStyle,
        document: document
    };
}
var EventReplayer = /** @class */ (function () {
    function EventReplayer() {
        this.clientNodeCache = {};
        this.replayStarted = false;
    }
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     */
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @param {?} win
     * @return {?}
     */
    EventReplayer.prototype.setWindow = /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @param {?} win
     * @return {?}
     */
    function (win) {
        this.win = win;
    };
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     */
    /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @return {?}
     */
    EventReplayer.prototype.getWindow = /**
     * Window setting and getter to facilitate testing of window
     * in non-browser environments
     * @return {?}
     */
    function () {
        if (!this.win) {
            this.win = _window();
        }
        return this.win;
    };
    /**
     * Replay all events for all apps. this can only be run once.
     * if called multiple times, will only do something once
     */
    /**
     * Replay all events for all apps. this can only be run once.
     * if called multiple times, will only do something once
     * @return {?}
     */
    EventReplayer.prototype.replayAll = /**
     * Replay all events for all apps. this can only be run once.
     * if called multiple times, will only do something once
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.replayStarted) {
            return;
        }
        else {
            this.replayStarted = true;
        }
        // loop through each of the preboot apps
        var /** @type {?} */ prebootData = this.getWindow().prebootData || {};
        var /** @type {?} */ apps = prebootData.apps || [];
        apps.forEach(function (appData) { return _this.replayForApp(appData); });
        // once all events have been replayed and buffers switched, then we cleanup preboot
        this.cleanup(prebootData);
    };
    /**
     * Replay all events for one app (most of the time there is just one app)
     * @param appData
     */
    /**
     * Replay all events for one app (most of the time there is just one app)
     * @param {?} appData
     * @return {?}
     */
    EventReplayer.prototype.replayForApp = /**
     * Replay all events for one app (most of the time there is just one app)
     * @param {?} appData
     * @return {?}
     */
    function (appData) {
        var _this = this;
        appData = /** @type {?} */ ((appData || {}));
        // try catch around events b/c even if error occurs, we still move forward
        try {
            var /** @type {?} */ root = /** @type {?} */ ((appData.root || {}));
            var /** @type {?} */ events = appData.events || [];
            // some client side frameworks (like Angular 1 w UI Router) will replace
            // elements, so we need to re-get client root just to be safe
            var /** @type {?} */ doc = this.getWindow().document;
            var /** @type {?} */ clientSelector = root.clientSelector;
            if (clientSelector != null) {
                root.clientNode = /** @type {?} */ (doc.querySelector(clientSelector));
            }
            // replay all the events from the server view onto the client view
            events.forEach(function (event) { return _this.replayEvent(appData, event); });
        }
        catch (/** @type {?} */ ex) {
            console.error(ex);
        }
        // if we are buffering, switch the buffers
        this.switchBuffer(appData);
    };
    /**
     * Replay one particular event
     * @param appData
     * @param prebootEvent
     */
    /**
     * Replay one particular event
     * @param {?} appData
     * @param {?} prebootEvent
     * @return {?}
     */
    EventReplayer.prototype.replayEvent = /**
     * Replay one particular event
     * @param {?} appData
     * @param {?} prebootEvent
     * @return {?}
     */
    function (appData, prebootEvent) {
        appData = /** @type {?} */ ((appData || {}));
        prebootEvent = /** @type {?} */ ((prebootEvent || {}));
        var /** @type {?} */ event = /** @type {?} */ (prebootEvent.event);
        var /** @type {?} */ serverNode = prebootEvent.node || {};
        var /** @type {?} */ nodeKey = prebootEvent.nodeKey;
        var /** @type {?} */ clientNode = this.findClientNode({
            root: appData.root,
            node: serverNode,
            nodeKey: nodeKey
        });
        // if client node can't be found, log a warning
        if (!clientNode) {
            console.warn("Trying to dispatch event " + event.type + " to node " + nodeKey + " but could not find client node. Server node is: ");
            console.log(serverNode);
            return;
        }
        // now dispatch events and whatnot to the client node
        (/** @type {?} */ (clientNode)).checked = serverNode.checked;
        (/** @type {?} */ (clientNode)).selected = serverNode.selected;
        (/** @type {?} */ (clientNode)).value = serverNode.value;
        clientNode.dispatchEvent(event);
    };
    /**
     * Switch the buffer for one particular app (i.e. display the client
     * view and destroy the server view)
     * @param appData
     */
    /**
     * Switch the buffer for one particular app (i.e. display the client
     * view and destroy the server view)
     * @param {?} appData
     * @return {?}
     */
    EventReplayer.prototype.switchBuffer = /**
     * Switch the buffer for one particular app (i.e. display the client
     * view and destroy the server view)
     * @param {?} appData
     * @return {?}
     */
    function (appData) {
        appData = /** @type {?} */ ((appData || {}));
        var /** @type {?} */ root = /** @type {?} */ ((appData.root || {}));
        var /** @type {?} */ serverView = root.serverNode;
        var /** @type {?} */ clientView = root.clientNode;
        // if no client view or the server view is the body or client
        // and server view are the same, then don't do anything and return
        if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {
            return;
        }
        // do a try-catch just in case something messed up
        try {
            // get the server view display mode
            var /** @type {?} */ gcs = this.getWindow().getComputedStyle;
            var /** @type {?} */ display = gcs(serverView).getPropertyValue('display') || 'block';
            // first remove the server view
            serverView.remove ? serverView.remove() : (serverView.style.display = 'none');
            // now add the client view
            clientView.style.display = display;
        }
        catch (/** @type {?} */ ex) {
            console.error(ex);
        }
    };
    /**
     * Finally, set focus, remove all the event listeners and remove
     * any freeze screen that may be there
     * @param prebootData
     */
    /**
     * Finally, set focus, remove all the event listeners and remove
     * any freeze screen that may be there
     * @param {?} prebootData
     * @return {?}
     */
    EventReplayer.prototype.cleanup = /**
     * Finally, set focus, remove all the event listeners and remove
     * any freeze screen that may be there
     * @param {?} prebootData
     * @return {?}
     */
    function (prebootData) {
        var _this = this;
        prebootData = prebootData || {};
        var /** @type {?} */ listeners = prebootData.listeners || [];
        // set focus on the active node AFTER a small delay to ensure buffer
        // switched
        var /** @type {?} */ activeNode = prebootData.activeNode;
        if (activeNode != null) {
            setTimeout(function () { return _this.setFocus(activeNode); }, 1);
        }
        // remove all event listeners
        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
            var listener = listeners_1[_i];
            listener.node.removeEventListener(listener.eventName, listener.handler);
        }
        // remove the freeze overlay if it exists
        var /** @type {?} */ doc = this.getWindow().document;
        var /** @type {?} */ prebootOverlay = /** @type {?} */ (doc.body.querySelector('#prebootOverlay'));
        if (prebootOverlay) {
            prebootOverlay.remove();
        }
        // clear out the data stored for each app
        prebootData.apps = [];
        this.clientNodeCache = {};
        // sent event to documernt that signals preboot complete
        var /** @type {?} */ completeEvent = new Event('PrebootComplete');
        doc.dispatchEvent(completeEvent);
    };
    /**
     * @param {?} activeNode
     * @return {?}
     */
    EventReplayer.prototype.setFocus = /**
     * @param {?} activeNode
     * @return {?}
     */
    function (activeNode) {
        // only do something if there is an active node
        if (!activeNode || !activeNode.node || !activeNode.nodeKey) {
            return;
        }
        // find the client node in the new client view
        var /** @type {?} */ clientNode = this.findClientNode(activeNode);
        if (clientNode) {
            // set focus on the client node
            clientNode.focus();
            // set selection if a modern browser (i.e. IE9+, etc.)
            var /** @type {?} */ selection = activeNode.selection;
            if ((/** @type {?} */ (clientNode)).setSelectionRange && selection) {
                try {
                    (/** @type {?} */ (clientNode)).setSelectionRange(selection.start, selection.end, selection.direction);
                }
                catch (/** @type {?} */ ex) { }
            }
        }
    };
    /**
     * Given a node from the server rendered view, find the equivalent
     * node in the client rendered view. We do this by the following approach:
     *      1. take the name of the server node tag (ex. div or h1 or input)
     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)
     *      3. use that value as a selector to get all the matching client nodes
     *      4. loop through all client nodes found and for each generate a key value
     *      5. compare the client key to the server key; once there is a match,
     *          we have our client node
     *
     * NOTE: this only works when the client view is almost exactly the same as
     * the server view. we will need an improvement here in the future to account
     * for situations where the client view is different in structure from the
     * server view
     */
    /**
     * Given a node from the server rendered view, find the equivalent
     * node in the client rendered view. We do this by the following approach:
     *      1. take the name of the server node tag (ex. div or h1 or input)
     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)
     *      3. use that value as a selector to get all the matching client nodes
     *      4. loop through all client nodes found and for each generate a key value
     *      5. compare the client key to the server key; once there is a match,
     *          we have our client node
     *
     * NOTE: this only works when the client view is almost exactly the same as
     * the server view. we will need an improvement here in the future to account
     * for situations where the client view is different in structure from the
     * server view
     * @param {?} serverNodeContext
     * @return {?}
     */
    EventReplayer.prototype.findClientNode = /**
     * Given a node from the server rendered view, find the equivalent
     * node in the client rendered view. We do this by the following approach:
     *      1. take the name of the server node tag (ex. div or h1 or input)
     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)
     *      3. use that value as a selector to get all the matching client nodes
     *      4. loop through all client nodes found and for each generate a key value
     *      5. compare the client key to the server key; once there is a match,
     *          we have our client node
     *
     * NOTE: this only works when the client view is almost exactly the same as
     * the server view. we will need an improvement here in the future to account
     * for situations where the client view is different in structure from the
     * server view
     * @param {?} serverNodeContext
     * @return {?}
     */
    function (serverNodeContext) {
        serverNodeContext = /** @type {?} */ ((serverNodeContext || {}));
        var /** @type {?} */ serverNode = serverNodeContext.node;
        var /** @type {?} */ root = serverNodeContext.root;
        // if no server or client root, don't do anything
        if (!root || !root.serverNode || !root.clientNode) {
            return null;
        }
        // we use the string of the node to compare to the client node & as key in
        // cache
        var /** @type {?} */ serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);
        // if client node already in cache, return it
        if (this.clientNodeCache[serverNodeKey]) {
            return /** @type {?} */ (this.clientNodeCache[serverNodeKey]);
        }
        // get the selector for client nodes
        var /** @type {?} */ className = (serverNode.className || '').replace('ng-binding', '').trim();
        var /** @type {?} */ selector = serverNode.tagName;
        if (serverNode.id) {
            selector += '#' + serverNode.id;
        }
        else if (className) {
            selector += '.' + className.replace(/ /g, '.');
        }
        // select all possible client nodes and look through them to try and find a
        // match
        var /** @type {?} */ rootClientNode = root.clientNode;
        var /** @type {?} */ clientNodes = rootClientNode.querySelectorAll(selector);
        // if nothing found, then just try the tag name as a final option
        if (!clientNodes.length) {
            console.log('nothing found for ' + selector + ' so using ' + serverNode.tagName);
            clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);
        }
        for (var _i = 0, _a = Array.from(clientNodes); _i < _a.length; _i++) {
            var clientNode = _a[_i];
            // get the key for the client node
            var /** @type {?} */ clientNodeKey = getNodeKeyForPreboot({
                root: root,
                node: clientNode
            });
            // if the client node key is exact match for the server node key, then we
            // found the client node
            if (clientNodeKey === serverNodeKey) {
                this.clientNodeCache[serverNodeKey] = clientNode;
                return /** @type {?} */ (clientNode);
            }
        }
        // if we get here and there is one clientNode, use it as a fallback
        if (clientNodes.length === 1) {
            this.clientNodeCache[serverNodeKey] = clientNodes[0];
            return /** @type {?} */ (clientNodes[0]);
        }
        // if we get here it means we couldn't find the client node so give the user
        // a warning
        console.warn('No matching client node found for ' + serverNodeKey + '. You can fix this by assigning this element a unique id attribute.');
        return null;
    };
    return EventReplayer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Called right away to initialize preboot
 *
 * @param {?} opts All the preboot options
 * @param {?=} win
 * @return {?}
 */
function init(opts, win) {
    var /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    // add the preboot options to the preboot data and then add the data to
    // the window so it can be used later by the client
    var /** @type {?} */ data = (theWindow.prebootData = /** @type {?} */ ({
        opts: opts,
        listening: true,
        apps: [],
        listeners: []
    }));
    // start up preboot listening as soon as the DOM is ready
    waitUntilReady(data);
}
/**
 * We want to attach event handlers as soon as possible. Unfortunately this
 * means before DOMContentLoaded fires, so we need to look for document.body to
 * exist instead.
 * @param {?} data
 * @param {?=} win
 * @return {?}
 */
function waitUntilReady(data, win) {
    var /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    var /** @type {?} */ doc = /** @type {?} */ ((theWindow.document || {}));
    if (doc.body) {
        start(data);
    }
    else {
        setTimeout(function () {
            waitUntilReady(data);
        }, 10);
    }
}
/**
 * Start up preboot by going through each app and assigning the appropriate
 * handlers. Normally this wouldn't be called directly, but we have set it up so
 * that it can for older versions of Universal.
 *
 * @param {?} prebootData Global preboot data object that contains options and will
 * have events
 * @param {?=} win Optional param to pass in mock window for testing purposes
 * @return {?}
 */
function start(prebootData, win) {
    var /** @type {?} */ theWindow = /** @type {?} */ ((win || window));
    // only start once
    if (theWindow.prebootStarted) {
        return;
    }
    else {
        theWindow.prebootStarted = true;
    }
    var /** @type {?} */ document = /** @type {?} */ ((theWindow.document || {}));
    var /** @type {?} */ opts = prebootData.opts || (/** @type {?} */ ({}));
    var /** @type {?} */ eventSelectors = opts.eventSelectors || [];
    // create an overlay that can be used later if a freeze event occurs
    prebootData.overlay = createOverlay(document);
    // get an array of all the root info
    var /** @type {?} */ appRoots = prebootData.opts ? getAppRoots(document, prebootData.opts) : [];
    // for each app root
    appRoots.forEach(function (root) {
        // we track all events for each app in the prebootData object which is on
        // the global scope
        var /** @type {?} */ appData = /** @type {?} */ ({ root: root, events: [] });
        if (prebootData.apps) {
            prebootData.apps.push(appData);
        }
        // loop through all the eventSelectors and create event handlers
        eventSelectors.forEach(function (eventSelector) { return handleEvents(prebootData, appData, eventSelector); });
    });
}
/**
 * Create an overlay div and add it to the DOM so it can be used
 * if a freeze event occurs
 *
 * @param {?} document The global document object (passed in for testing purposes)
 * @return {?} Element The overlay node is returned
 */
function createOverlay(document) {
    var /** @type {?} */ overlay = undefined;
    if (document.createElement) {
        overlay = document.createElement('div');
        overlay.setAttribute('id', 'prebootOverlay');
        overlay.setAttribute('style', 'display:none;position:absolute;left:0;' + 'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3');
        document.body.appendChild(overlay);
    }
    return overlay;
}
/**
 * Get references to all app root nodes based on input options. Users can
 * initialize preboot either by specifying appRoot which is just one or more
 * selectors for apps. This section option is useful for people that are doing their own
 * buffering (i.e. they have their own client and server view)
 *
 * @param {?} doc
 * @param {?} opts Options passed in by the user to init()
 * @return {?} ServerClientRoot[] An array of root info for each app
 */
function getAppRoots(doc, opts) {
    var /** @type {?} */ roots = [];
    // loop through any appRoot selectors to add them to the list of roots
    if (opts.appRoot && opts.appRoot.length) {
        var /** @type {?} */ baseList = [];
        var /** @type {?} */ appRootSelectors = baseList.concat(opts.appRoot);
        appRootSelectors.forEach(function (selector) { return roots.push({ serverSelector: selector }); });
    }
    return roots.map(function (root) {
        root.serverNode = /** @type {?} */ (doc.querySelector(root.serverSelector));
        root.clientSelector = root.clientSelector || root.serverSelector;
        if (root.clientSelector !== root.serverSelector) {
            // if diff selectors, then just get the client node
            root.clientNode = /** @type {?} */ (doc.querySelector(root.clientSelector));
        }
        else {
            // if we are doing buffering, we need to create the buffer for the client
            // else the client root is the same as the server
            root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;
        }
        // if no server node found, log error
        if (!root.serverNode) {
            console.log("No server node found for selector: " + root.serverSelector);
        }
        return root;
    });
}
/**
 * Under given server root, for given selector, record events
 *
 * @param {?} prebootData
 * @param {?} appData
 * @param {?} eventSelector
 * @return {?}
 */
function handleEvents(prebootData, appData, eventSelector) {
    var /** @type {?} */ serverRoot = appData.root.serverNode;
    // don't do anything if no server root
    if (!serverRoot) {
        return;
    }
    // get all nodes under the server root that match the given selector
    var /** @type {?} */ nodes = serverRoot.querySelectorAll(eventSelector.selector);
    // don't do anything if no nodes found
    if (!nodes) {
        return;
    }
    var _loop_1 = function (node) {
        eventSelector.events.forEach(function (eventName) {
            // get the appropriate handler and add it as an event listener
            var /** @type {?} */ handler = createListenHandler(prebootData, eventSelector, appData, node);
            node.addEventListener(eventName, handler);
            // need to keep track of listeners so we can do node.removeEventListener()
            // when preboot done
            if (prebootData.listeners) {
                prebootData.listeners.push({ node: /** @type {?} */ (node), eventName: eventName, handler: handler });
            }
        });
    };
    // we want to add an event listener for each node and each event
    for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {
        var node = _a[_i];
        _loop_1(node);
    }
}
/**
 * Create handler for events that we will record
 * @param {?} prebootData
 * @param {?} eventSelector
 * @param {?} appData
 * @param {?} node
 * @return {?}
 */
function createListenHandler(prebootData, eventSelector, appData, node) {
    var /** @type {?} */ CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];
    var /** @type {?} */ CARET_NODES = ['INPUT', 'TEXTAREA'];
    return function (event) {
        var /** @type {?} */ root = appData.root;
        var /** @type {?} */ eventName = event.type;
        // if no node or no event name or not listening, just return
        if (!node || !eventName) {
            return;
        }
        // if key codes set for eventSelector, then don't do anything if event
        // doesn't include key
        var /** @type {?} */ keyCodes = eventSelector.keyCodes;
        if (keyCodes && keyCodes.length) {
            var /** @type {?} */ matchingKeyCodes = keyCodes.filter(function (keyCode) { return event.which === keyCode; });
            // if there are not matches (i.e. key entered NOT one of the key codes)
            // then don't do anything
            if (!matchingKeyCodes.length) {
                return;
            }
        }
        // if for a given set of events we are preventing default, do that
        if (eventSelector.preventDefault) {
            event.preventDefault();
        }
        // if an action handler passed in, use that
        if (eventSelector.action) {
            eventSelector.action(node, event);
        }
        // get the node key for a given node
        var /** @type {?} */ nodeKey = getNodeKeyForPreboot({ root: root, node: node });
        // if event on input or text area, record active node
        if (CARET_EVENTS.indexOf(eventName) >= 0 && CARET_NODES.indexOf(node.tagName) >= 0) {
            prebootData.activeNode = {
                root: root,
                node: node,
                nodeKey: nodeKey,
                selection: getSelection(/** @type {?} */ (node))
            };
        }
        else if (eventName !== 'change' && eventName !== 'focusout') {
            prebootData.activeNode = undefined;
        }
        // if we are freezing the UI
        if (eventSelector.freeze) {
            var /** @type {?} */ overlay_1 = /** @type {?} */ (prebootData.overlay);
            // show the overlay
            // show the overlay
            overlay_1.style.display = 'block';
            // hide the overlay after 10 seconds just in case preboot.complete() never
            // called
            setTimeout(function () {
                overlay_1.style.display = 'none';
            }, 10000);
        }
        // we will record events for later replay unless explicitly marked as
        // doNotReplay
        if (!eventSelector.noReplay) {
            appData.events.push({ node: node, nodeKey: nodeKey, event: event, name: eventName });
        }
    };
}
/**
 * Get the selection data that is later used to set the cursor after client view
 * is active
 * @param {?} node
 * @return {?}
 */
function getSelection(node) {
    node = node || /** @type {?} */ ({});
    var /** @type {?} */ nodeValue = node.value || '';
    var /** @type {?} */ selection = {
        start: nodeValue.length,
        end: nodeValue.length,
        direction: 'forward'
    };
    // if browser support selectionStart on node (Chrome, FireFox, IE9+)
    try {
        if (node.selectionStart || node.selectionStart === 0) {
            selection.start = node.selectionStart;
            selection.end = node.selectionEnd;
            selection.direction = node.selectionDirection;
        }
    }
    catch (/** @type {?} */ ex) { }
    return selection;
}
/**
 * Create buffer for a given node
 *
 * @param {?} root All the data related to a particular app
 * @return {?} Returns the root client node.
 */
function createBuffer(root) {
    var /** @type {?} */ serverNode = root.serverNode;
    // if no rootServerNode OR the selector is on the entire html doc or the body
    // OR no parentNode, don't buffer
    if (!serverNode || !serverNode.parentNode || root.serverSelector === 'html' || root.serverSelector === 'body') {
        return /** @type {?} */ (serverNode);
    }
    // create shallow clone of server root
    var /** @type {?} */ rootClientNode = /** @type {?} */ (serverNode.cloneNode(false));
    // we want the client to write to a hidden div until the time for switching
    // the buffers
    rootClientNode.style.display = 'none';
    // insert the client node before the server and return it
    serverNode.parentNode.insertBefore(rootClientNode, serverNode);
    // return the rootClientNode
    return rootClientNode;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var eventRecorder = {
    waitUntilReady: waitUntilReady,
    start: start,
    createOverlay: createOverlay,
    getAppRoots: getAppRoots,
    handleEvents: handleEvents,
    createListenHandler: createListenHandler,
    getSelection: getSelection,
    createBuffer: createBuffer
};
// exporting default options in case developer wants to use these + custom on
// top
var defaultOptions = /** @type {?} */ ({
    buffer: true,
    minify: true,
    // these are the default events are are listening for an transfering from
    // server view to client view
    eventSelectors: [
        // for recording changes in form elements
        {
            selector: 'input,textarea',
            events: ['keypress', 'keyup', 'keydown', 'input', 'change']
        },
        { selector: 'select,option', events: ['change'] },
        // when user hits return button in an input box
        {
            selector: 'input',
            events: ['keyup'],
            preventDefault: true,
            keyCodes: [13],
            freeze: true
        },
        // when user submit form (press enter, click on button/input[type="submit"])
        {
            selector: 'form',
            events: ['submit'],
            preventDefault: true,
            freeze: true
        },
        // for tracking focus (no need to replay)
        {
            selector: 'input,textarea',
            events: ['focusin', 'focusout', 'mousedown', 'mouseup'],
            noReplay: true
        },
        // user clicks on a button
        {
            selector: 'button',
            events: ['click'],
            preventDefault: true,
            freeze: true
        }
    ]
});
/**
 * Get the event recorder code based on all functions in event.recorder.ts
 * and the getNodeKeyForPreboot function.
 * @return {?}
 */
function getEventRecorderCode() {
    var /** @type {?} */ eventRecorderFunctions = [];
    for (var /** @type {?} */ funcName in eventRecorder) {
        if (eventRecorder.hasOwnProperty(funcName)) {
            var /** @type {?} */ fn = (/** @type {?} */ (eventRecorder))[funcName].toString();
            var /** @type {?} */ fnCleaned = fn.replace('common_1.', '');
            eventRecorderFunctions.push(fnCleaned);
        }
    }
    // this is common function used to get the node key
    eventRecorderFunctions.push(getNodeKeyForPreboot.toString());
    // add new line characters for readability
    return '\n\n' + eventRecorderFunctions.join('\n\n') + '\n\n';
}
/**
 * Used by the server side version of preboot. The main purpose
 * is to get the inline code that can be inserted into the server view.
 *
 * @param {?=} customOptions PrebootRecordOptions that override the defaults
 * @return {?} Generated inline preboot code is returned
 */
function getInlinePrebootCode(customOptions) {
    var /** @type {?} */ opts = /** @type {?} */ (assign({}, defaultOptions, customOptions));
    // safety check to make sure options passed in are valid
    validateOptions(opts);
    var /** @type {?} */ optsStr = stringifyWithFunctions(opts);
    var /** @type {?} */ scriptCode = getEventRecorderCode();
    // TODO re-add minification option?
    // wrap inline preboot code with a self executing function in order to create scope
    var /** @type {?} */ initStr = init.toString();
    return "(function() {\n      " + scriptCode + "\n      (" + initStr.replace('common_1.', '') + "\n      )(" + optsStr + ")\n    })()";
}
/**
 * Throw an error if issues with any options
 * @param {?} opts
 * @return {?}
 */
function validateOptions(opts) {
    if (!opts.appRoot || !opts.appRoot.length) {
        throw new Error('The appRoot is missing from preboot options. ' +
            'This is needed to find the root of your application. ' +
            'Set this value in the preboot options to be a selector for the root element of your app.');
    }
}
/**
 * Object.assign() is not fully supporting in TypeScript, so
 * this is just a simple implementation of it
 *
 * @param {?} target The target object
 * @param {...?} optionSets Any number of addition objects that are added on top of the
 * target
 * @return {?} A new object that contains all the merged values
 */
function assign(target) {
    var optionSets = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionSets[_i - 1] = arguments[_i];
    }
    if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    var /** @type {?} */ output = Object(target);
    for (var /** @type {?} */ index = 0; index < optionSets.length; index++) {
        var /** @type {?} */ source = optionSets[index];
        if (source !== undefined && source !== null) {
            for (var /** @type {?} */ nextKey in source) {
                if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                }
            }
        }
    }
    return output;
}
/**
 * Stringify an object and include functions. This is needed since we are
 * letting users pass in options that include custom functions for things like
 * the freeze handler or action when an event occurs
 *
 * @param {?} obj This is the object you want to stringify that includes some
 * functions
 * @return {?} The stringified version of an object
 */
function stringifyWithFunctions(obj) {
    var /** @type {?} */ FUNC_START = 'START_FUNCTION_HERE';
    var /** @type {?} */ FUNC_STOP = 'STOP_FUNCTION_HERE';
    // first stringify except mark off functions with markers
    var /** @type {?} */ str = JSON.stringify(obj, function (_key, value) {
        // if the value is a function, we want to wrap it with markers
        if (!!(value && value.constructor && value.call && value.apply)) {
            return FUNC_START + value.toString() + FUNC_STOP;
        }
        else {
            return value;
        }
    });
    // now we use the markers to replace function strings with actual functions
    var /** @type {?} */ startFuncIdx = str.indexOf(FUNC_START);
    var /** @type {?} */ stopFuncIdx;
    var /** @type {?} */ fn;
    while (startFuncIdx >= 0) {
        stopFuncIdx = str.indexOf(FUNC_STOP);
        // pull string out
        fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);
        fn = fn.replace(/\\n/g, '\n');
        str = str.substring(0, startFuncIdx - 1) + fn + str.substring(stopFuncIdx + FUNC_STOP.length + 1);
        startFuncIdx = str.indexOf(FUNC_START);
    }
    return str;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PREBOOT_OPTIONS = new _angular_core.InjectionToken('PrebootOptions');
/**
 * @param {?} doc
 * @param {?} rendererFactory
 * @param {?} recordOpts
 * @param {?} nonce
 * @param {?} platformId
 * @return {?}
 */
function addScript(doc, rendererFactory, recordOpts, nonce, platformId) {
    // necessary because of angular/angular/issues/14485
    var /** @type {?} */ res = function () {
        if (_angular_common.isPlatformServer(platformId)) {
            var /** @type {?} */ inlineCode = getInlinePrebootCode(recordOpts);
            var /** @type {?} */ renderType = { id: '-1', encapsulation: _angular_core.ViewEncapsulation.None, styles: [], data: {} };
            var /** @type {?} */ renderer = rendererFactory.createRenderer(doc, renderType);
            var /** @type {?} */ script = renderer.createElement('script');
            if (nonce) {
                renderer.setProperty(script, 'nonce', nonce);
            }
            renderer.setValue(script, inlineCode);
            renderer.insertBefore(doc.head, script, doc.head.firstChild);
        }
    };
    return res;
}
/**
 * @param {?} eventReplayer
 * @param {?} replayOpts
 * @param {?} platformId
 * @return {?}
 */
function replay(eventReplayer, replayOpts, platformId) {
    // necessary because of angular/angular/issues/14485
    var /** @type {?} */ res = function () {
        if (_angular_common.isPlatformBrowser(platformId) && !replayOpts.noReplay) {
            eventReplayer.replayAll();
        }
    };
    return res;
}
var PrebootModule = /** @class */ (function () {
    function PrebootModule() {
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    PrebootModule.withConfig = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        return {
            ngModule: PrebootModule,
            providers: [
                EventReplayer,
                { provide: PREBOOT_OPTIONS, useValue: opts },
                {
                    provide: _angular_core.APP_BOOTSTRAP_LISTENER,
                    useFactory: addScript,
                    deps: [
                        _angular_common.DOCUMENT,
                        _angular_core.RendererFactory2,
                        PREBOOT_OPTIONS,
                        [new _angular_core.Optional(), new _angular_core.Inject(PREBOOT_NONCE)],
                        _angular_core.PLATFORM_ID
                    ],
                    multi: true
                },
                {
                    provide: _angular_core.APP_BOOTSTRAP_LISTENER,
                    useFactory: replay,
                    deps: [EventReplayer, PREBOOT_OPTIONS, _angular_core.PLATFORM_ID],
                    multi: true
                }
            ]
        };
    };
    PrebootModule.decorators = [
        { type: _angular_core.NgModule },
    ];
    /** @nocollapse */
    PrebootModule.ctorParameters = function () { return []; };
    return PrebootModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

exports.getNodeKeyForPreboot = getNodeKeyForPreboot;
exports.PREBOOT_NONCE = PREBOOT_NONCE;
exports._window = _window;
exports.EventReplayer = EventReplayer;
exports.init = init;
exports.waitUntilReady = waitUntilReady;
exports.start = start;
exports.createOverlay = createOverlay;
exports.getAppRoots = getAppRoots;
exports.handleEvents = handleEvents;
exports.createListenHandler = createListenHandler;
exports.getSelection = getSelection;
exports.createBuffer = createBuffer;
exports.defaultOptions = defaultOptions;
exports.getEventRecorderCode = getEventRecorderCode;
exports.getInlinePrebootCode = getInlinePrebootCode;
exports.validateOptions = validateOptions;
exports.assign = assign;
exports.stringifyWithFunctions = stringifyWithFunctions;
exports.PREBOOT_OPTIONS = PREBOOT_OPTIONS;
exports.addScript = addScript;
exports.replay = replay;
exports.PrebootModule = PrebootModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=preboot.umd.js.map
